#include <esp_now.h>
#include <WiFi.h>

// --- C·∫§U H√åNH ---
// üî¥ ƒêI·ªÄN MAC C·ª¶A CON REMOTE (C·∫ÆM M√ÅY T√çNH) V√ÄO ƒê√ÇY
uint8_t remoteMAC[] = {0x78, 0x1C, 0x3C, 0xE1, 0x0F, 0x0C};

// C·∫•u tr√∫c ph·∫£i kh·ªõp ho√†n to√†n v·ªõi Remote
typedef struct command_struct {
  int x;
  int y;
} command_struct;

typedef struct feedback_struct {
  float voltage;
  int distance;
} feedback_struct;

command_struct recvCommand;
feedback_struct sendFeedback;
esp_now_peer_info_t peerInfo;
unsigned long lastTime = 0;

// --- 1. H√ÄM ƒêI·ªÄU KHI·ªÇN MOTOR ---
void controlMotor(int x, int y) {
  // Code ƒëi·ªÅu khi·ªÉn motor c·ªßa b·∫°n ƒë·∫∑t ·ªü ƒë√¢y
  // V√≠ d·ª•: Serial.printf("Motor running: %d, %d\n", x, y);
}

// --- 2. H√ÄM NH·∫¨N L·ªÜNH (ƒê√£ s·ª≠a cho b·∫£n m·ªõi) ---
// Tham s·ªë ƒë·∫ßu ti√™n ph·∫£i l√† 'const esp_now_recv_info_t *'
void OnDataRecv(const esp_now_recv_info_t * info, const uint8_t *incomingData, int len) {
  memcpy(&recvCommand, incomingData, sizeof(recvCommand));
  
  // In ra ƒë·ªÉ ki·ªÉm tra
  Serial.print("Nhan lenh -> X: ");
  Serial.println(recvCommand.x);
  
  controlMotor(recvCommand.x, recvCommand.y);
}

// --- 3. H√ÄM G·ª¨I PH·∫¢N H·ªíI (ƒê√£ s·ª≠a cho b·∫£n m·ªõi) ---
// QUAN TR·ªåNG: Tham s·ªë ƒë·∫ßu ti√™n ph·∫£i l√† 'const wifi_tx_info_t *' thay v√¨ 'const uint8_t *'
void OnDataSent(const wifi_tx_info_t *info, esp_now_send_status_t status) {
  // B·∫°n c√≥ th·ªÉ l·∫•y MAC ng∆∞·ªùi nh·∫≠n t·ª´ info->peer_addr n·∫øu c·∫ßn
  // Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Gui OK" : "Gui Loi");
}

void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);

  // Kh·ªüi t·∫°o ESP-NOW
  if (esp_now_init() != ESP_OK) {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  // ƒêƒÉng k√Ω Callback (Kh√¥ng c·∫ßn √©p ki·ªÉu n·ªØa v√¨ h√†m ƒë√£ vi·∫øt ƒë√∫ng chu·∫©n)
  esp_now_register_recv_cb(OnDataRecv);
  esp_now_register_send_cb(OnDataSent);

  // ƒêƒÉng k√Ω Remote l√† Peer ƒë·ªÉ g·ª≠i ph·∫£n h·ªìi v·ªÅ
  memcpy(peerInfo.peer_addr, remoteMAC, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
  
  if (esp_now_add_peer(&peerInfo) != ESP_OK){
    Serial.println("Failed to add peer");
  }
}

void loop() {
  // C·ª© m·ªói 1 gi√¢y (1000ms), g·ª≠i th√¥ng b√°o v·ªÅ Remote m·ªôt l·∫ßn
  if (millis() - lastTime > 1000) {
    lastTime = millis();
    
    // 1. Thu th·∫≠p d·ªØ li·ªáu (Gi·∫£ l·∫≠p)
    sendFeedback.voltage = 12.5; // Gi·∫£ v·ªù pin ƒëang 12.5V
    sendFeedback.distance = random(10, 200); // Gi·∫£ v·ªù kho·∫£ng c√°ch random

    // 2. G·ª≠i v·ªÅ Remote
    esp_now_send(remoteMAC, (uint8_t *) &sendFeedback, sizeof(sendFeedback));
  }
}